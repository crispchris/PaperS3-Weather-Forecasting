#include <M5Unified.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <ArduinoJson.h>
#include <time.h>
#include <SD.h>

// ==== CONFIG ====
const char* ssid     = "YourWiFi";
const char* password = "YourPassword";
const char* city     = "Valparaiso,CL";
const char* apiKey   = "YOUR_OPENWEATHERMAP_KEY";
const char* units    = "metric";
bool useDeepSleep    = true;
int  sleepMinutes    = 60;

// ==== TIME ====
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = -4 * 3600;   // UTC−4 for Chile Standard Time
const int daylightOffset_sec = 3600;

// ==== GLOBALS ====
HTTPClient http;
float temp, feels_like, humidity;
String weatherDesc, weatherIcon;
struct ForecastDay { String date; float tmin, tmax; String desc, icon; };
ForecastDay forecast[3];


// === monochrome bitmaps ===
// simple AI‑crafted icons (1‑bit, 512 B each)

const uint8_t icon_sun[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x03,0xE7,0xC0,0x00,0x00,0x00,0x00,
  0x00,0x03,0xC3,0xC0,0x00,0x00,0x00,0x00,0x00,0x03,0xC3,0xC0,0x00,0x00,0x00,0x00,
  0x00,0x03,0xE7,0xC0,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x00,0x00,
  0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00
};

const uint8_t icon_cloud[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,
  0x00,0x7F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,
  0x01,0xC0,0x70,0x00,0x00,0x00,0x00,0x00,0x03,0x80,0x38,0x00,0x00,0x00,0x00,0x00,
  0x07,0xFC,0x3C,0x00,0x00,0x00,0x00,0x00,0x0F,0xFE,0x3E,0x00,0x00,0x00,0x00,0x00,
  0x1F,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,
  0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,
  0x7F,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00
};

const uint8_t icon_rain[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xE3,0x80,0x00,0x00,0x00,0x00,0x00,0x01,0xC1,0xC0,0x00,0x00,0x00,0x00,0x00,
  0x03,0x81,0xE0,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
  0x0F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x10,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x28,0x00,0x00,0x00,0x00,0x00,
  0x40,0x10,0x04,0x00,0x00,0x00,0x00,0x00,0x10,0x08,0x10,0x00,0x00,0x00,0x00,0x00,
  0x28,0x00,0x28,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x04,0x00,0x00,0x00,0x00,0x00
};

const uint8_t icon_thunder[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3C,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0xC7,0x80,0x00,0x00,0x00,0x00,0x00,0x03,0x83,0xC0,0x00,0x00,0x00,0x00,
  0x00,0x07,0x01,0xE0,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xF0,0x00,0x00,0x00,0x00,
  0x00,0x1F,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,0x3F,0xFF,0xFC,0x00,0x00,0x00,0x00,
  0x00,0x38,0xF0,0x1C,0x00,0x00,0x00,0x00,0x00,0x70,0x78,0x0E,0x00,0x00,0x00,0x00,
  0x00,0xE0,0x3C,0x07,0x00,0x00,0x00,0x00,0x01,0xC0,0x1E,0x03,0x80,0x00,0x00,0x00,
  0x03,0x80,0x0F,0x01,0xC0,0x00,0x00,0x00
};

const uint8_t icon_snow[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,
  0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x38,0x00,0x00,0x00,0x00,0x00,
  0x7C,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,
  0x7C,0x00,0x7C,0x00,0x00,0x00,0x00,0x00,0x38,0x00,0x38,0x00,0x00,0x00,0x00,0x00,
  0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00
};

const uint8_t icon_mist[] PROGMEM = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

void drawIcon(const uint8_t *bmp, int x, int y, int scale=6) {
  const int W = 64;
  const int H = 16;
  const int BYTES_PER_ROW = W / 8;
  const int TOTAL_BYTES = BYTES_PER_ROW * H;

  for (int j=0; j<H; j++) {
    int rowOffset = j * BYTES_PER_ROW;
    for (int i=0; i<W; i++) {
      int byteIndex = rowOffset + (i >> 3);
      if (byteIndex >= TOTAL_BYTES) continue;
      int bitIndex = 7 - (i & 7);
      uint8_t b = pgm_read_byte(&bmp[byteIndex]);
      if ((b >> bitIndex) & 1)
        M5.Display.fillRect(x + i*scale, y + j*scale, scale, scale, TFT_BLACK);
    }
  }
}

// === selector ===
void drawWeatherIcon(String code, int x, int y) {
  if (code.startsWith("01")) {
    drawIcon(icon_sun, x, y);
    Serial.printf("icon_sun");
  }
  else if (code.startsWith("02")) {
    drawIcon(icon_sun, x, y);       // sun+cloud could reuse sun
    Serial.printf("icon_sun");
  }
  else if (code.startsWith("03") || code.startsWith("04")) {
    drawIcon(icon_cloud, x, y);
    Serial.printf("icon_cloud");
  }
  else if (code.startsWith("09") || code.startsWith("10")) {
    drawIcon(icon_rain, x, y);
    Serial.printf("icon_rain");
  }
  else if (code.startsWith("11")) {
    drawIcon(icon_thunder, x, y);
    Serial.printf("icon_thunder");
  }
  else if (code.startsWith("13")) { 
    drawIcon(icon_snow, x, y);
    Serial.printf("icon_snow");
  }
  else if (code.startsWith("50")) {
    drawIcon(icon_mist, x, y);
    Serial.printf("icon_mist");
  }
  else {
    drawIcon(icon_cloud, x, y); // default
    Serial.printf("icon_cloud");
  }
}

// ==== UTILITIES ====
void connectWiFi() {
  Serial.printf("Connecting to WiFi: %s\n", ssid);
  WiFi.begin(ssid, password);
  for (int i=0; i<40 && WiFi.status()!=WL_CONNECTED; i++) { delay(500); Serial.print("."); }
  if (WiFi.status()!=WL_CONNECTED) { Serial.println("WiFi failed, restarting..."); delay(2000); ESP.restart(); }
  Serial.printf("\nConnected. IP: %s\n", WiFi.localIP().toString().c_str());
}

void syncTime() {
  Serial.println("Syncing time...");
  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
  struct tm info;
  if (!getLocalTime(&info, 5000)) Serial.println("Time sync failed!");
  else Serial.println("Time sync OK");
}

bool safeGET(String url, String &out) {
  Serial.printf("HTTP GET: %s\n", url.c_str());
  http.begin(url);
  http.setTimeout(8000);
  int code = http.GET();
  if (code == 200) { out = http.getString(); http.end(); return true; }
  Serial.printf("HTTP error: %s\n", http.errorToString(code).c_str());
  http.end(); return false;
}

// ==== WEATHER FETCH ====
bool fetchCurrent() {
  String payload;
  String url = "http://api.openweathermap.org/data/2.5/weather?q=" + String(city) +
               "&appid=" + apiKey + "&units=" + units;
  if (!safeGET(url, payload)) return false;

  DynamicJsonDocument doc(4096);
  if (deserializeJson(doc, payload)) { Serial.println("JSON parse error"); return false; }
  temp        = doc["main"]["temp"];
  feels_like  = doc["main"]["feels_like"];
  humidity    = doc["main"]["humidity"];
  weatherDesc = (const char*)doc["weather"][0]["description"];
  weatherIcon = (const char*)doc["weather"][0]["icon"];
  Serial.printf("Current: %.1f C hum %.0f%% %s (%s)\n", temp, humidity, weatherDesc.c_str(), weatherIcon.c_str());
  return true;
}

bool fetchForecast() {
  String payload;
  String url = "http://api.openweathermap.org/data/2.5/forecast?q=" + String(city) +
               "&appid=" + apiKey + "&units=" + units;
  if (!safeGET(url, payload)) return false;

  DynamicJsonDocument doc(12288);
  if (deserializeJson(doc, payload)) { Serial.println("Forecast JSON parse error"); return false; }

  for (int d=0; d<3; d++) {
    JsonObject e = doc["list"][d*8];
    if (e.isNull()) continue;
    forecast[d].date = String((const char*)e["dt_txt"]).substring(5,10);
    forecast[d].tmin = e["main"]["temp_min"];
    forecast[d].tmax = e["main"]["temp_max"];
    forecast[d].desc = (const char*)e["weather"][0]["description"];
    forecast[d].icon = (const char*)e["weather"][0]["icon"];
  }
  return true;
}


void resetScreen() {
  Serial.println("Drawing to display...");
  M5.Display.wakeup();
  M5.Display.setEpdMode(epd_mode_t::epd_fast);
  M5.Display.setRotation(1);
  M5.Display.fillScreen(TFT_WHITE);
  M5.Display.display();
  M5.Display.waitDisplay();
}

// ==== DRAW ====
void drawWeather() {
  Serial.println("Drawing to display...");
  resetScreen();
  resetScreen();
  resetScreen();
  M5.Display.wakeup();
  M5.Display.setEpdMode(epd_mode_t::epd_fast);
  M5.Display.setRotation(1);
  M5.Display.fillScreen(TFT_WHITE);
  M5.Display.setTextColor(TFT_BLACK, TFT_WHITE);

  for (int i = 0; i < 3; i++) {
    int y = 10;
    M5.Display.setTextDatum(TL_DATUM);
    M5.Display.setTextSize(4);
    M5.Display.setCursor(15, y);
    struct tm now;
    if (getLocalTime(&now)) {
      char buf[32];
      strftime(buf, sizeof(buf), "%d.%m %H:%M", &now);
      M5.Display.setCursor(15, y);
      M5.Display.printf("%s    %s", city, buf);
    }

    y += 50;
    M5.Display.setCursor(15, y);
    drawWeatherIcon(weatherIcon, 15, y);
    M5.Display.setTextSize(12);

    y += 20;
    M5.Display.setCursor(230, y);
    M5.Display.printf("%.1f C", temp);

    
    y += 140;
    M5.Display.setTextSize(8);
    M5.Display.setCursor(15, y);
    M5.Display.printf("%s", weatherDesc.c_str());
    M5.Display.setTextSize(6);

    y += 80;
    M5.Display.setCursor(15, y);
    M5.Display.printf("Feels %.1f C | Hum %.0f%%", feels_like, humidity);

    y += 60;
    M5.Display.setTextSize(4);
    for (int i=0;i<3;i++) {
      M5.Display.setCursor(15, y);
      M5.Display.printf("%s   high %.0f C, low %.0f C", forecast[i].date.c_str(), forecast[i].tmax, forecast[i].tmin);
      y += 40;
    }

    M5.Display.display();
    M5.Display.waitDisplay();
  }
  delay(2000);
  Serial.println("Display updated.");
}

// ==== MAIN ====
void setup() {
  Serial.begin(115200);
  Serial.println("\n=== PaperS3 Weather ===");

  auto cfg = M5.config();
  cfg.output_power = true;
  M5.begin(cfg);  
  M5.Power.begin();

  M5.Display.wakeup();
  M5.Display.setEpdMode(epd_mode_t::epd_quality);
  M5.Display.fillScreen(TFT_WHITE);
  M5.Display.setTextColor(TFT_BLACK);
  M5.Display.setTextSize(3);
  M5.Display.setCursor(20, 100);
  M5.Display.println("Connecting WiFi...");
  M5.Display.display();

  connectWiFi();
  syncTime();

  bool ok1 = fetchCurrent();
  bool ok2 = fetchForecast();
  
  if (ok1 && ok2) drawWeather();
  else {
    M5.Display.fillScreen(TFT_WHITE);
    M5.Display.setTextColor(TFT_BLACK);
    M5.Display.setTextSize(3);
    M5.Display.setCursor(20, 100);
    M5.Display.println("Fetch failed");
    M5.Display.display();
  }

  if (useDeepSleep) {
    WiFi.disconnect(true);
    esp_sleep_enable_timer_wakeup((uint64_t)sleepMinutes * 60ULL * 1000000ULL);
    esp_deep_sleep_start();
  }
}

void loop() {}
